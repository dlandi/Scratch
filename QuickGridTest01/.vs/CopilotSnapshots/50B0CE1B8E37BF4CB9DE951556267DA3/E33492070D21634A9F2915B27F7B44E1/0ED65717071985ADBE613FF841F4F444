using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.QuickGrid;
using Microsoft.AspNetCore.Components.Rendering;
using Microsoft.AspNetCore.Components.Web;
using System.Linq.Expressions;

namespace QuickGridTest01.CustomColumns;

public class EditableColumn<TGridItem, TValue> : ColumnBase<TGridItem>
{
    [Parameter] public Expression<Func<TGridItem, TValue>> Property { get; set; } = default!;
    [Parameter] public List<IValidator<TValue>> Validators { get; set; } = new();
    [Parameter] public string? Format { get; set; }
    [Parameter] public string? InputType { get; set; }
    [Parameter] public EventCallback<CellValueChangedArgs<TGridItem, object>> OnValueChanged { get; set; }
    [Parameter] public bool ValidateOnChange { get; set; } = true;
    [Parameter] public RenderFragment<TValue>? DisplayTemplate { get; set; }

    private readonly Dictionary<TGridItem, EditState<TValue>> _editStates = new();
    private Expression<Func<TGridItem, TValue>>? _lastProperty;
    private Func<TGridItem, TValue>? _compiledProperty;
    private Action<TGridItem, TValue>? _propertySetter;
    private Func<TGridItem, string?>? _cellTextFunc;
    private GridSort<TGridItem>? _sortBuilder;

    public override GridSort<TGridItem>? SortBy
    {
        get => _sortBuilder;
        set => _sortBuilder = value;
    }

    protected override void OnInitialized()
    {
        if (Property is null)
        {
            throw new InvalidOperationException(
                $"{nameof(EditableColumn<TGridItem, TValue>)} requires a {nameof(Property)} parameter.");
        }

        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        if (Title is null && Property.Body is MemberExpression memberExpression)
        {
            Title = memberExpression.Member.Name;
        }

        if (_lastProperty != Property)
        {
            _lastProperty = Property;
            _compiledProperty = Property.Compile();
            _propertySetter = BuildPropertySetter();

            if (!string.IsNullOrEmpty(Format))
            {
                _cellTextFunc = item =>
                {
                    var value = _compiledProperty!(item);
                    if (value is IFormattable formattable)
                    {
                        return formattable.ToString(Format, null);
                    }
                    return value?.ToString();
                };
            }
            else
            {
                _cellTextFunc = item => _compiledProperty!(item)?.ToString();
            }

            if (Sortable ?? false)
            {
                _sortBuilder = GridSort<TGridItem>.ByAscending(Property);
            }
        }

        base.OnParametersSet();
    }

    protected override void CellContent(RenderTreeBuilder builder, TGridItem item)
    {
        var state = GetOrCreateEditState(item);
        
        if (state.IsEditing)
        {
            RenderEditMode(builder, item, state);
        }
        else
        {
            RenderDisplayMode(builder, item, state);
        }
    }

    private void RenderDisplayMode(RenderTreeBuilder builder, TGridItem item, EditState<TValue> state)
    {
        int sequence = 0;
        builder.OpenElement(sequence++, "div");
        builder.AddAttribute(sequence++, "class", "editable-cell display-mode");
        // Prevent any parent handlers from interfering (e.g., row clicks)
        builder.AddAttribute(sequence++, "onclick:stopPropagation", true);
        // Click or double-click to enter edit
        builder.AddAttribute(sequence++, "onclick", EventCallback.Factory.Create<MouseEventArgs>(this, (MouseEventArgs _) => EnterEditMode(item)));
        builder.AddAttribute(sequence++, "ondblclick", EventCallback.Factory.Create<MouseEventArgs>(this, (MouseEventArgs _) => EnterEditMode(item)));
        builder.AddAttribute(sequence++, "title", "Click to edit");

        if (DisplayTemplate is not null)
        {
            var value = _compiledProperty!(item);
            builder.AddContent(sequence++, DisplayTemplate(value));
        }
        else
        {
            var text = _cellTextFunc!(item);
            builder.OpenElement(sequence++, "span");
            builder.AddAttribute(sequence++, "class", "cell-value");
            builder.AddContent(sequence++, text ?? string.Empty);
            builder.CloseElement();
        }

        builder.OpenElement(sequence++, "i");
        builder.AddAttribute(sequence++, "class", "bi bi-pencil edit-icon");
        builder.CloseElement();

        builder.CloseElement();
    }

    private void RenderEditMode(RenderTreeBuilder builder, TGridItem item, EditState<TValue> state)
    {
        int sequence = 0;
        builder.OpenElement(sequence++, "div");
        builder.AddAttribute(sequence++, "class", $"editable-cell edit-mode {(state.IsValid ? "" : "invalid")}");
        builder.AddAttribute(sequence++, "onclick:stopPropagation", true);

        RenderEditor(builder, ref sequence, item, state);

        builder.OpenElement(sequence++, "div");
        builder.AddAttribute(sequence++, "class", "edit-actions");

        builder.OpenElement(sequence++, "button");
        builder.AddAttribute(sequence++, "type", "button");
        builder.AddAttribute(sequence++, "class", "btn-save");
        builder.AddAttribute(sequence++, "onclick", EventCallback.Factory.Create(this, 
            () => SaveEdit(item)));
        builder.AddAttribute(sequence++, "disabled", state.IsValidating || !state.IsValid);
        builder.AddAttribute(sequence++, "title", state.IsValid ? "Save" : "Fix validation errors");
        builder.OpenElement(sequence++, "i");
        builder.AddAttribute(sequence++, "class", "bi bi-check");
        builder.CloseElement();
        builder.CloseElement();

        builder.OpenElement(sequence++, "button");
        builder.AddAttribute(sequence++, "type", "button");
        builder.AddAttribute(sequence++, "class", "btn-cancel");
        builder.AddAttribute(sequence++, "onclick", EventCallback.Factory.Create(this, 
            () => CancelEdit(item)));
        builder.AddAttribute(sequence++, "title", "Cancel");
        builder.OpenElement(sequence++, "i");
        builder.AddAttribute(sequence++, "class", "bi bi-x");
        builder.CloseElement();
        builder.CloseElement();

        builder.CloseElement();

        if (!state.IsValid && state.ErrorMessages.Any())
        {
            builder.OpenElement(sequence++, "div");
            builder.AddAttribute(sequence++, "class", "validation-errors");
            foreach (var error in state.ErrorMessages)
            {
                builder.OpenElement(sequence++, "div");
                builder.AddAttribute(sequence++, "class", "validation-error");
                builder.AddContent(sequence++, error);
                builder.CloseElement();
            }
            builder.CloseElement();
        }

        if (state.IsValidating)
        {
            builder.OpenElement(sequence++, "div");
            builder.AddAttribute(sequence++, "class", "validation-loading");
            builder.AddContent(sequence++, "Validating...");
            builder.CloseElement();
        }

        builder.CloseElement();
    }

    private void RenderEditor(RenderTreeBuilder builder, ref int sequence, TGridItem item, EditState<TValue> state)
    {
        var inputType = GetInputType();
        builder.OpenElement(sequence++, "input");
        builder.AddAttribute(sequence++, "type", inputType);
        builder.AddAttribute(sequence++, "class", "edit-input");
        builder.AddAttribute(sequence++, "value", FormatValueForInput(state.CurrentValue));
        if (ValidateOnChange)
        {
            builder.AddAttribute(sequence++, "oninput", EventCallback.Factory.Create<ChangeEventArgs>(
                this, e => OnInputChanged(item, e)));
        }
        else
        {
            builder.AddAttribute(sequence++, "onchange", EventCallback.Factory.Create<ChangeEventArgs>(
                this, e => OnInputChanged(item, e)));
        }
        builder.AddAttribute(sequence++, "autofocus", true);
        builder.AddAttribute(sequence++, "onkeydown", EventCallback.Factory.Create<Microsoft.AspNetCore.Components.Web.KeyboardEventArgs>(
            this, e => OnKeyDown(item, e)));
        builder.CloseElement();
    }

    private string GetInputType()
    {
        if (!string.IsNullOrWhiteSpace(InputType))
            return InputType;
        var valueType = typeof(TValue);
        var underlyingType = Nullable.GetUnderlyingType(valueType) ?? valueType;
        if (underlyingType == typeof(DateTime)) return "date";
        if (underlyingType == typeof(int) || underlyingType == typeof(long)) return "number";
        if (underlyingType == typeof(decimal) || underlyingType == typeof(double)) return "number";
        if (underlyingType == typeof(bool)) return "checkbox";
        return "text";
    }

    private string FormatValueForInput(TValue? value)
    {
        if (value is null) return string.Empty;
        if (value is DateTime dateTime) return dateTime.ToString("yyyy-MM-dd");
        return value.ToString() ?? string.Empty;
    }

    private EditState<TValue> GetOrCreateEditState(TGridItem item)
    {
        if (!_editStates.TryGetValue(item, out var state))
        {
            state = new EditState<TValue>();
            _editStates[item] = state;
        }
        return state;
    }

    private void EnterEditMode(TGridItem item)
    {
        var state = GetOrCreateEditState(item);
        var currentValue = _compiledProperty!(item);
        state.BeginEdit(currentValue);
        StateHasChanged();
    }

    private async Task OnInputChanged(TGridItem item, ChangeEventArgs e)
    {
        var state = GetOrCreateEditState(item);
        try
        {
            var stringValue = e.Value?.ToString();
            if (string.IsNullOrWhiteSpace(stringValue))
            {
                state.CurrentValue = default;
            }
            else
            {
                state.CurrentValue = (TValue)Convert.ChangeType(stringValue,
                    Nullable.GetUnderlyingType(typeof(TValue)) ?? typeof(TValue));
            }
        }
        catch { }

        if (ValidateOnChange)
        {
            await ValidateAsync(state);
        }
        StateHasChanged();
    }

    private async Task OnKeyDown(TGridItem item, Microsoft.AspNetCore.Components.Web.KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SaveEdit(item);
        }
        else if (e.Key == "Escape")
        {
            CancelEdit(item);
        }
    }

    private async Task SaveEdit(TGridItem item)
    {
        var state = GetOrCreateEditState(item);
        if (!ValidateOnChange || state.ValidationResults.Count == 0)
        {
            await ValidateAsync(state);
        }
        if (!state.IsValid)
        {
            StateHasChanged();
            return;
        }
        if (state.IsDirty && _propertySetter is not null)
        {
            var oldValue = _compiledProperty!(item);
            _propertySetter(item, state.CurrentValue!);
            await OnValueChanged.InvokeAsync(new CellValueChangedArgs<TGridItem, object>
            {
                Item = item,
                OldValue = oldValue!,
                NewValue = state.CurrentValue!
            });
        }
        state.CommitEdit();
        StateHasChanged();
    }

    private void CancelEdit(TGridItem item)
    {
        var state = GetOrCreateEditState(item);
        state.CancelEdit();
        StateHasChanged();
    }

    private async Task ValidateAsync(EditState<TValue> state)
    {
        state.IsValidating = true;
        state.ValidationResults.Clear();
        StateHasChanged();
        try
        {
            foreach (var validator in Validators)
            {
                var result = await validator.ValidateAsync(state.CurrentValue);
                state.ValidationResults.Add(result);
            }
        }
        finally
        {
            state.IsValidating = false;
            StateHasChanged();
        }
    }

    private Action<TGridItem, TValue>? BuildPropertySetter()
    {
        if (Property.Body is not MemberExpression memberExpression)
            return null;
        var parameter = Property.Parameters[0];
        var valueParameter = Expression.Parameter(typeof(TValue), "value");
        var assign = Expression.Assign(memberExpression, valueParameter);
        var lambda = Expression.Lambda<Action<TGridItem, TValue>>(assign, parameter, valueParameter);
        return lambda.Compile();
    }
}

public class CellValueChangedArgs<TGridItem, TValue>
{
    public TGridItem Item { get; set; } = default!;
    public TValue OldValue { get; set; } = default!;
    public TValue NewValue { get; set; } = default!;
}
